<!doctype html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<title>Simple JS Physics</title>
	<style>
		* { margin:0; padding:0; background-color:#111111; }
		body { position: fixed; width: 100%; height: 100%; -webkit-user-select: none; }
	</style>
</head>
<body>
	
	<canvas id="stage" width="400" height="400">
		<p>Your browser doesn't support canvas.</p>
	</canvas>
		
<script type="text/javascript" src="Vector2D.js"></script>
<script type="text/javascript" src="geom/Circle.js"></script>
<script type="text/javascript">

// GLOBALS
von.gravity = 0;
von.friction = 0.98;
von.ctx = null;

(function () {	
var stage = document.getElementById('stage');

var objects = [];
var total = 5;

var stageWidth = window.innerWidth;
var	stageHeight = window.innerHeight;
stage.width = stageWidth;
stage.height = stageHeight;

window.onresize = function(evt) {
	stage.width = 10;
	stage.height = 10;
	stageWidth = window.innerWidth;
	stageHeight = window.innerHeight;
	stage.width = stageWidth;
	stage.height = stageHeight;
}

var _pi = Math.PI, _tau = pi*2, _rad = 0.0174532925199;

window.addEventListener('load', function loaded(evt) {
	window.removeEventListener('load', loaded);
	
	ctx = stage.getContext('2d');
	
	var i, o, a = 0, ao = _tau / total,
		wx = stageWidth/2, wy = stageHeight/2;
	
	for (i = 0; i < total; i++) {
		o = new von.Circle(Math.cos(a) * 100 + wx, Math.sin(a) * 100 + wy);
		objects.push(o);
	}
	
	_mark = Date.now();
	tick();
});

/**********************
 * End initializing
 */

function tick() {
	ctx.clearRect(0, 0, stageWidth, stageHeight);
	var now = Date.now(),
		dt = now - _mark;
	
	_mark = now;
	von.elapsed = dt * 0.001;
	
	// motion (and usually gameplay)
	var i, j, a, b;
	for (i = 0; i < total; ++i) {
		objects[i].update();
	}
	
	// physics
	var m;
	for (i = 0; i < (total-1); ++i) {
		a = objects[i];
		
		for (j = i + 1; j < total; ++j) {
			b = objects[j];
			
			collision(a, b);
			// if (collision(a, b)) resolveCollision(a, b);
		}
	}
	
	// drawing
	for (i = 0; i < total; ++i) {
		objects[i].render();
	}
	
	window.webkitRequestAnimationFrame(tick);
}

var _difference = new Vector2D();
var _normal = new Vector2D();
var _vd = new Vector2D();
var _impulse = new Vector2D();
var _mtd = new Vector2D();

function collideBalls(a, b, resolve) {
	// ball
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	var dist = (dx * dx)  + (dy * dy);
	var radii = a.radius + b.radius;
	if (dist < radii * radii) {
		dist = Math.sqrt(dx * dx + dy * dy);
		// vector
		_difference.reset(dx, dy);
		if (dist == 0)  {
			dist = a.radius + b.radius - 1;
			_difference.reset(radii, radii); // i don't think...
		}
		// vector
		_mtd.reset(); // WHAT THE FUCK COME ON
		var mtd = delta * ((a.radius + b.radius) - dist) / dist;
		if (typeof resolve !== 'undefined') {
			// resolveCollision(a, b, mtd);
		}
	}
}
/*function resolveCollision(a, b) {
	// impact speed
	v = A.v - B.v

	// normalize mtd
	mtdNormal = mtd.normalize()
	vn = dot(v, mtdNormal)
	// if the vn is > 0, then the 2 balls are intersecting, but they're moving away from each other already
	if (vn > 0) return false

	// impulse
	// the restitution is the ball's elasticity. 1 is elastic, < 1 is inelastic
	i = -((1 + restitution) * vn) / (im1 + im2)
	impulse = mtdNormal * i

	// apply impulses
	A.V += impulse * im1
	B.V -= impulse * im2
}*/
}());
</script>
</body>
</html>